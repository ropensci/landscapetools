% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/util_extract_multibuffer.R
\name{util_extract_multibuffer}
\alias{util_extract_multibuffer}
\title{Extract raster values for multiple buffers}
\usage{
util_extract_multibuffer(
  landscape,
  points,
  buffer_width,
  max_width = NULL,
  rel_freq = FALSE,
  fun = NULL,
  point_id_text = TRUE,
  ...
)
}
\arguments{
\item{landscape}{\verb{Raster*} object}

\item{points}{Point(s) represented by a two-column matrix or \code{data.frame}; \verb{SpatialPoints*}; \verb{SpatialPolygons*};
\code{SpatialLines}; \code{Extent}; a numeric vector representing cell numbers; or \verb{sf*} POINT object.}

\item{buffer_width}{Buffer width in which landscape share is measured. It might be either a single value
or a vector of buffer sizes, if \code{max_width = NULL} (default). If a value if provided for \code{max_width},
a series of buffer sizes is created, from \code{buffer_width} to \code{max_width}, with increases of
\code{buffer_width}.}

\item{max_width}{Maximum distance to which buffer_width is summed up. If \code{NULL}, \code{buffer_width} is
interpreted as a series of buffers.}

\item{rel_freq}{Logical. If \code{TRUE}, the relative frequency of raster values is returned, instead of
the absolute frequency. Ignored if \code{fun} is provided.}

\item{fun}{Function to apply to raster values within the buffer.}

\item{point_id_text}{Logical. If \code{TRUE}, a text with "Point ID:" is added to the first column
of the output.}

\item{...}{additional arguments (none implemented)}
}
\value{
A tibble with the frequency of each raster value within the buffers of different sizes
around each point. Alternatively, a tibble with the relative frequency of raster values, if \code{rel_freq = TRUE},
or a function from the raster values, if \code{fun} is provided.
}
\description{
This function creates a series of circular buffers around spatial points and computes
the frequency of each value of a raster within the buffers; the results are printed in
a \code{data.frame}.
}
\examples{
# create single point
new_point = matrix(c(75,75), ncol = 2)

# show landscape and point of interest
show_landscape(classified_landscape, discrete = TRUE) +
ggplot2::geom_point(data = data.frame(x = new_point[,1], y = new_point[,2]),
                    ggplot2::aes(x = x, y = y),
                    col = "grey", size = 3)

# show single point share
util_extract_multibuffer(classified_landscape, new_point, 10, 50)
# relative frequency
util_extract_multibuffer(classified_landscape, new_point, 10, 50, rel_freq = TRUE)
# function
util_extract_multibuffer(classified_landscape, new_point, 10, 50, fun = median)

}
